<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>MirrorFall</title>

<!-- iOS Web App Meta (for "Add to Home Screen" look) -->
<link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="MirrorFall">

<!-- Manifest (optional, good for PWA) -->
<link rel="manifest" href="manifest.json">

<style>
  /* Landscape-first, centered canvas */
  html,body{
    height:100%;
    margin:0;
    background:#000;
    color:#fff;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    -webkit-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    overflow:hidden;
  }

  #gameWrap{
    display:flex;
    align-items:center;
    justify-content:center;
    height:100%;
    width:100%;
    box-sizing:border-box;
    padding:10px;
  }

  canvas#game {
    background: linear-gradient(#050507, #0b0b0f 60%);
    width:100%;
    height:100%;
    max-height:100vh;
    max-width:1600px;
    image-rendering: optimizeSpeed;
    border-radius:8px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.8);
    display:block;
  }

  /* UI overlays */
  #ui {
    position: absolute;
    left:12px;
    top:12px;
    z-index:20;
    pointer-events:none;
  }
  #score {
    font-size:18px;
    font-weight:600;
    text-shadow:0 2px 8px rgba(0,0,0,0.8);
  }
  #controlsHint {
    position: absolute;
    right:12px;
    top:12px;
    pointer-events:none;
    font-size:14px;
    opacity:0.85;
  }

  /* Virtual touch controls for mobile (large, translucent) */
  .touchbtn {
    position: absolute;
    bottom:22px;
    width:38%;
    height:32%;
    border-radius:12px;
    pointer-events:auto;
    opacity:0.02; /* nearly invisible but receives touches */
    -webkit-user-select:none;
  }
  .leftTouch { left:6px; }
  .rightTouch { right:6px; }

  /* Visible virtual buttons for desktop testing (toggle with ? key) */
  .visBtn {
    position: absolute;
    bottom:18px;
    width:120px;
    height:48px;
    background:rgba(255,255,255,0.06);
    color:#fff;
    border-radius:8px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:700;
    letter-spacing:1px;
    pointer-events:none;
  }
  #jumpBtn { left:18px; }
  #dashBtn { right:18px; }

  /* Simple instructions center */
  #overlay {
    position:absolute;
    z-index:30;
    left:0; right:0; top:0; bottom:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  #overlay .panel{
    max-width:780px;
    text-align:center;
    background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.6));
    border-radius:12px;
    padding:18px 26px;
    box-shadow: 0 6px 30px rgba(0,0,0,0.7);
    pointer-events:auto;
  }
  button#startBtn {
    margin-top:12px;
    font-size:18px;
    padding:10px 18px;
    border-radius:8px;
    border:0;
    background:#ff2f5a;
    color:white;
    font-weight:700;
  }

  /* Jumpscare full-screen flash */
  #jumpscare {
    position: absolute;
    inset:0;
    background:#000;
    z-index:999;
    display:none;
    align-items:center;
    justify-content:center;
    color:#fff;
    font-size:48px;
    font-weight:900;
    text-shadow: 0 6px 40px #ff2f5a;
  }

  @media (orientation:portrait) {
    /* Tell user to rotate */
    #portraitWarning {
      position: absolute;
      inset:0;
      z-index:200;
      background:linear-gradient(0deg, rgba(0,0,0,0.85), rgba(0,0,0,0.9));
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:20px;
      color:#fff;
      font-size:20px;
      pointer-events:none;
    }
  }
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="game" width="1280" height="720"></canvas>

  <div id="ui">
    <div id="score">Score: 0</div>
  </div>
  <div id="controlsHint">
    Controls: ← → / A D or tap left/right. Controller supported (A jump, B dash). Press ? for help.
  </div>

  <!-- Invisible touch areas -->
  <div class="touchbtn leftTouch" id="leftTouch"></div>
  <div class="touchbtn rightTouch" id="rightTouch"></div>

  <!-- Visible debug buttons -->
  <div id="jumpBtn" class="visBtn" style="display:none;">JUMP</div>
  <div id="dashBtn" class="visBtn" style="display:none;">DASH</div>

  <div id="overlay">
    <div class="panel" id="panel">
      <h1 style="margin:0;letter-spacing:2px">MirrorFall</h1>
      <p style="margin:6px 0 0 0">You are being chased by your mirror self. You have a flashlight. Run. Survive as long as you can.</p>
      <p style="margin:8px 0 0 0; font-size:13px; opacity:0.9">
        Quick play: tap or press A to jump, B or right-tap to dash (short speed burst). Flashlight (F or touch-hold left) stuns mirror briefly.
      </p>
      <div style="margin-top:12px;">
        <button id="startBtn">Start Run</button>
      </div>
      <p style="font-size:12px;margin-top:8px;opacity:0.8">Pro tip: staying near the center gives better reaction space — but the Mirror learns.</p>
    </div>
  </div>

  <div id="jumpscare">THE MIRROR TOOK YOU</div>
  <div id="portraitWarning" style="display:none">Rotate device to landscape for best experience.</div>
</div>

<script>
/* MirrorFall — core variables and game loop
   Single-file engine using canvas.
   Controls: keyboard, touch (left/right halves), gamepad support.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
let W = canvas.width, H = canvas.height;

// Scaling to device pixel ratio for crisp canvas
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  // maintain 16:9 landscape when possible
  const wrap = document.getElementById('gameWrap');
  const maxW = Math.min(window.innerWidth - 20, 1600);
  const maxH = Math.min(window.innerHeight - 20, 900);
  // Fit into view preserving aspect ratio
  const targetRatio = 16/9;
  let cw = maxW, ch = Math.round(cw / targetRatio);
  if (ch > maxH) { ch = maxH; cw = Math.round(ch * targetRatio); }
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  W = canvas.width = Math.round(cw * ratio);
  H = canvas.height = Math.round(ch * ratio);
  ctx.setTransform(ratio, 0, 0, ratio, 0, 0); // scale drawing commands
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Game state
let running = false;
let paused = false;
let score = 0;
let speed = 4;       // world scroll speed
let timeElapsed = 0;
let difficulty = 0;  // increases with time
let lastTimestamp = 0;

// Player
const player = {
  x: 180, y: 0, w: 28, h: 56,
  vy: 0,
  grounded: false,
  baseY: 0,
  jumpPower: -12,
  dashTime: 0,
  dashCooldown: 0,
  maxDashCooldown: 0.8,
  flashlightCharge: 1.0,
  flashlightActive: false
};

// Mirror (pursuer)
const mirror = {
  x: 40,
  speed: 3.2,
  anger: 0 // affects aggressiveness & jumpscare chance
};

// Obstacles and pickups
let obstacles = [];
let pickups = [];

// Config / tuning
const GRAV = 0.6;
const OBSTACLE_SPAWN_RATE = 1.0; // per second baseline
const PICKUP_SPAWN_RATE = 0.12;
const MIN_GAP = 220;
const MAX_GAP = 520;
const MAX_OBSTACLE_SPEED = 12;

// Visual flash (jumpscare) control
const jumpscareEl = document.getElementById('jumpscare');

const uiScore = document.getElementById('score');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
startBtn.onclick = startGame;

// Input state
const keys = {};
const touches = { left:false, right:false };
let showVisibleBtns = false;

// Gamepad
let gpIndex = null;
let lastGamepadTimestamp = 0;

/* ---------- Utility functions ---------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function randInt(min,max){ return Math.floor(rand(min,max+1)); }

/* ---------- Start / Reset ---------- */
function startGame(){
  overlay.style.display = 'none';
  running = true;
  paused = false;
  score = 0;
  timeElapsed = 0;
  speed = 4;
  difficulty = 0;
  lastTimestamp = performance.now();
  obstacles = [];
  pickups = [];
  player.vy = 0;
  player.grounded = true;
  player.dashTime = 0;
  player.dashCooldown = 0;
  player.flashlightCharge = 1.0;
  player.flashlightActive = false;
  mirror.x = 40;
  mirror.speed = 3.2;
  mirror.anger = 0;
  requestAnimationFrame(loop);
}

/* ---------- Input handlers ---------- */
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.key === '?') toggleHelp();
  if (e.key === 'p') paused = !paused;
  // Prevent scrolling on space etc
  if (['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

function toggleHelp() {
  showVisibleBtns = !showVisibleBtns;
  document.querySelectorAll('.visBtn').forEach(el=>el.style.display = showVisibleBtns ? 'flex' : 'none');
}

// Touch handlers: left area = jump/flashlight, right area = dash
const leftTouch = document.getElementById('leftTouch');
const rightTouch = document.getElementById('rightTouch');

leftTouch.addEventListener('touchstart', e => { touches.left = true; e.preventDefault(); });
leftTouch.addEventListener('touchend', e => { touches.left = false; e.preventDefault(); });

rightTouch.addEventListener('touchstart', e => { touches.right = true; e.preventDefault(); });
rightTouch.addEventListener('touchend', e => { touches.right = false; e.preventDefault(); });

/* ---------- Gamepad API ---------- */
window.addEventListener("gamepadconnected", (e) => {
  gpIndex = e.gamepad.index;
  console.log("Gamepad connected:", e.gamepad.id);
});
window.addEventListener("gamepaddisconnected", (e) => {
  if (gpIndex === e.gamepad.index) gpIndex = null;
  console.log("Gamepad disconnected.");
});

function pollGamepad() {
  if (gpIndex === null) return null;
  const gp = navigator.getGamepads()[gpIndex];
  if (!gp) return null;
  // Typical mapping: button 0 = A (jump), 1 = B (dash)
  // left stick axis 0 (-1 left, +1 right)
  return gp;
}

/* ---------- World generation: obstacles & pickups ---------- */
let spawnTimer = 0;
let pickupTimer = 0;
function maybeSpawn(dt){
  spawnTimer += dt;
  pickupTimer += dt;
  const rate = Math.max(0.3, OBSTACLE_SPAWN_RATE - difficulty*0.02);
  if (spawnTimer > 1/rate){
    spawnTimer = 0;
    spawnObstacle();
  }
  if (pickupTimer > 1/PICKUP_SPAWN_RATE){
    pickupTimer = 0;
    if (Math.random() < 0.6) spawnPickup();
  }
}

function spawnObstacle(){
  const obstacle = {
    x: W + 60,
    y: H - 140,
    w: randInt(28, 72),
    h: randInt(28, 84),
    type: 'block',
    speedFactor: 1 + difficulty*0.01 + Math.random()*0.6
  };
  // small chance for ground hole
  if (Math.random() < 0.12){
    obstacle.type = 'low';
    obstacle.h = 30;
  }
  obstacles.push(obstacle);
}

function spawnPickup(){
  const p = {
    x: W + 60,
    y: H - 240 - Math.random()*120,
    r: 12,
    kind: Math.random() < 0.6 ? 'score' : 'boost',
    speedFactor: 1
  };
  pickups.push(p);
}

/* ---------- Collision helpers ---------- */
function rectsOverlap(a,b){
  return a.x < b.x + b.w &&
         a.x + a.w > b.x &&
         a.y < b.y + b.h &&
         a.y + a.h > b.y;
}

/* ---------- Flashlight mechanic ----------
   Flashlight slows or briefly stuns mirror when applied (gently).
   Held by 'F' key or left touch hold. */
function useFlashlight(dt){
  if (player.flashlightActive && player.flashlightCharge > 0){
    player.flashlightCharge = Math.max(0, player.flashlightCharge - dt*0.7);
    mirror.speed = Math.max(1.6, mirror.speed - dt*1.2);
    mirror.anger = Math.max(0, mirror.anger - dt*0.1);
  } else {
    // recharge over time
    player.flashlightCharge = Math.min(1, player.flashlightCharge + dt*0.22);
  }
}

/* ---------- Update ---------- */
function update(dt){
  if (!running || paused) return;

  // time
  timeElapsed += dt;
  difficulty = Math.min(100, timeElapsed * 0.03);
  score = Math.floor(timeElapsed * 10 + (mirror.x < 60 ? 0 : 0)); // base scoring on time
  uiScore.textContent = 'Score: ' + score;

  // Input mapping
  const gp = pollGamepad();
  let gpJump = false, gpDash = false;
  if (gp){
    gpJump = gp.buttons[0].pressed;
    gpDash = gp.buttons[1].pressed;
    // axes left-right to strafe? we don't move horizontally; we could use for dodge later
  }
  // Jump: space, arrowUp, keyW, 'KeyA'? Use ArrowUp/Space/W or left touch quick tap
  const jumpPressed = keys['Space'] || keys['ArrowUp'] || keys['KeyW'] || touches.left || gpJump;
  const dashPressed = keys['KeyF'] || keys['ShiftLeft'] || touches.right || gpDash || keys['KeyD'] || keys['ArrowRight'];

  // Flashlight when holding 'KeyF' or long-press left touch
  player.flashlightActive = keys['KeyF'] || (touches.left && player.grounded === true && player.vy === 0 && false); // mostly avoid accidental hold
  // Also treat holding 'KeyF' or Gamepad left trigger? For now mapped to KeyF

  // Jump logic - allow jump on press, not hold (simple)
  if (jumpPressed && player.grounded){
    player.vy = player.jumpPower;
    player.grounded = false;
    // small boost if dash pressed simultaneously
    if (dashPressed && player.dashCooldown <= 0) {
      player.dashTime = 0.28;
      player.dashCooldown = player.maxDashCooldown;
    }
  }

  // Dash logic
  if (dashPressed && player.dashCooldown <= 0){
    player.dashTime = 0.28;
    player.dashCooldown = player.maxDashCooldown;
  }

  if (player.dashTime > 0){
    player.dashTime -= dt;
  } else {
    // cooldown reduction
    player.dashCooldown = Math.max(0, player.dashCooldown - dt);
  }

  // Gravity
  player.vy += GRAV;
  player.y += player.vy;

  // Ground
  const groundY = H - 120;
  player.baseY = groundY - player.h;
  if (player.y >= player.baseY){
    player.y = player.baseY;
    player.vy = 0;
    player.grounded = true;
  }

  // If dashing, increase world scroll temporarily
  let effectiveSpeed = speed + (player.dashTime > 0 ? 6 : 0) + (difficulty * 0.01);
  effectiveSpeed = Math.min(MAX_OBSTACLE_SPEED, effectiveSpeed);

  // Move obstacles & pickups left
  for (let i=obstacles.length-1; i>=0; i--){
    const ob = obstacles[i];
    ob.x -= effectiveSpeed * ob.speedFactor * dt * 60 / 16;
    if (ob.x + ob.w < -100) obstacles.splice(i,1);
  }
  for (let i=pickups.length-1; i>=0; i--){
    const p = pickups[i];
    p.x -= effectiveSpeed * p.speedFactor * dt * 60 / 16;
    if (p.x < -80) pickups.splice(i,1);
  }

  // Mirror movement: mirror slowly chases; gets faster when player uses dash or is ahead
  mirror.x += (mirror.speed + difficulty*0.007) * dt * 60 / 16;
  // Mirror reacts if player uses flashlight
  if (player.flashlightActive && player.flashlightCharge > 0){
    mirror.speed = Math.max(1.8, mirror.speed - 0.035);
  } else {
    mirror.speed = Math.min(8.5, mirror.speed + 0.02 + difficulty*0.001);
  }

  // Mirror angriness increases as it gets closer
  const distance = player.x - mirror.x;
  mirror.anger = Math.min(1, Math.max(0, 1 - (distance - 40)/420));

  // Collision with obstacles
  for (let ob of obstacles){
    const blox = {x: ob.x, y: ob.y, w: ob.w, h: ob.h};
    const ply = {x: player.x, y: player.y, w: player.w, h: player.h};
    if (rectsOverlap(blox, ply)){
      // collision — knock player backward and slow speed, add penalty to mirror approach
      // If the player was dashing, they may break through some obstacles
      if (player.dashTime > 0 && ob.w < 80){
        // break obstacle
        ob.h = Math.max(12, ob.h - 20);
        // spawn bits (not implemented)
      } else {
        // penalty: reduce player's dash and push mirror closer (makes things scarier)
        player.vy = -6; // small knockback jump
        player.grounded = false;
        mirror.x += 10;
        score = Math.max(0, score - 18);
      }
    }
  }

  // Pickup collisions
  for (let i=pickups.length-1;i>=0;i--){
    const p = pickups[i];
    const ply = {x: player.x, y: player.y, w: player.w, h: player.h};
    const pr = {x: p.x - p.r, y: p.y - p.r, w: p.r*2, h: p.r*2};
    if (rectsOverlap(ply, pr)){
      if (p.kind === 'score') score += 120;
      else if (p.kind === 'boost'){ player.dashCooldown = 0; player.dashTime = 0.5; player.flashlightCharge = Math.min(1, player.flashlightCharge + 0.35); }
      pickups.splice(i,1);
    }
  }

  // Flashlight usage
  // Allow left touch hold for flashlight. For simplicity: if left touch is held >0.4s AND not just tapped, treat as flashlight
  useFlashlight(dt);

  // Frequent small increase of mirror closeness if player is slow
  if (player.dashTime <= 0 && player.grounded && Math.abs(player.vy) < 0.1){
    // nothing
  }

  // Mirror catching check
  if (mirror.x + 40 >= player.x - 6){
    // Jumpscare / game over
    gameOver(true);
    return;
  }

  // Spawn
  maybeSpawn(dt);
}

/* ---------- Draw ---------- */
function drawHUD(){
  // flashlight bar
  const barW = 140, barH = 10;
  ctx.save();
  ctx.translate(12,12);
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(0,0,barW,barH);
  ctx.fillStyle = '#ffd54f';
  ctx.fillRect(0,0, barW * player.flashlightCharge, barH);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.strokeRect(0,0,barW,barH);
  ctx.fillStyle = '#fff';
  ctx.font = '12px system-ui';
  ctx.fillText('Flashlight', 0, -6);
  ctx.restore();
}

function drawScene(){
  // clear
  ctx.fillStyle = '#030306';
  ctx.fillRect(0,0,W,H);

  // parallax background (dark shapes)
  // draw faint tilted ground grid
  ctx.save();
  for (let i=0;i<12;i++){
    ctx.fillStyle = `rgba(255,255,255,${0.01 + i*0.01})`;
    ctx.fillRect((i*120 + (timeElapsed*8 % 120)) % (W+200) - 100, H-110, 80, 2);
  }
  ctx.restore();

  // ground
  ctx.fillStyle = '#0b0b0d';
  ctx.fillRect(0, H-120, W, 120);

  // obstacles
  for (let ob of obstacles){
    ctx.fillStyle = '#2b2b33';
    ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    // highlight edge
    ctx.strokeStyle = '#101019';
    ctx.strokeRect(ob.x, ob.y, ob.w, ob.h);
  }

  // pickups
  for (let p of pickups){
    if (p.kind === 'score'){
      ctx.fillStyle = '#8ef';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    } else {
      ctx.fillStyle = '#ff9';
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // heartbeat/fog effects for horror mood
  const fogAlpha = 0.08 + 0.05*Math.sin(timeElapsed*2.2);
  ctx.fillStyle = 'rgba(4,4,6,'+fogAlpha+')';
  ctx.fillRect(0,0,W,H-60);

  // flashlight cone: draw radial gradient in front of player
  if (player.flashlightCharge > 0 || player.flashlightActive){
    const g = ctx.createRadialGradient(player.x + 12, player.y + 12, 10, player.x + 360, player.y - 120, 420);
    g.addColorStop(0, 'rgba(255,255,200,0.95)');
    g.addColorStop(0.2, 'rgba(255,255,200,0.22)');
    g.addColorStop(0.6, 'rgba(20,20,24,0.04)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(player.x + 260, player.y - 80, 420, 240, -0.18, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }

  // player draw (simple stickman)
  ctx.save();
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(player.x - 4, player.y + player.h + 4, player.w + 8, 6);

  // body
  ctx.fillStyle = '#dfe2e6';
  ctx.fillRect(player.x, player.y, player.w, player.h);
  // head
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.arc(player.x + player.w/2, player.y - 10, 14, 0, Math.PI*2);
  ctx.fill();

  // flashlight handle
  ctx.fillStyle = '#202020';
  ctx.fillRect(player.x + player.w, player.y + player.h/3, 18, 8);
  ctx.restore();

  // mirror (pursuer) - partly transparent with red eyes
  ctx.save();
  const mirrorScreenX = mirror.x;
  const mirrorAlpha = 0.5 + mirror.anger*0.5;
  ctx.globalAlpha = mirrorAlpha;
  ctx.fillStyle = '#111027';
  ctx.fillRect(mirrorScreenX, player.baseY, player.w, player.h);
  // head
  ctx.beginPath();
  ctx.fillStyle = '#0b0b0b';
  ctx.arc(mirrorScreenX + player.w/2, player.baseY - 10, 14, 0, Math.PI*2);
  ctx.fill();
  // eyes (red)
  ctx.fillStyle = `rgba(255,${Math.floor(60 + mirror.anger*195)},60)`;
  ctx.fillRect(mirrorScreenX + 6, player.baseY - 14, 6, 4);
  ctx.fillRect(mirrorScreenX + 16, player.baseY - 14, 6, 4);
  ctx.globalAlpha = 1;
  ctx.restore();

  // small UI
  drawHUD();

  // Remainder: screen vignette for mood
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, 'rgba(0,0,0,0)');
  grad.addColorStop(0.8, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);
}

/* ---------- Gameover / Jumpscare ---------- */
function gameOver(isCaught){
  running = false;
  if (isCaught){
    // show jumpscare full-screen flash with sound
    jumpscareEl.style.display = 'flex';
    setTimeout(()=>{ jumpscareEl.style.display = 'none'; showOverlayEnd(); }, 1800);
    // optional sound
  } else {
    showOverlayEnd();
  }
}

function showOverlayEnd(){
  overlay.style.display = 'flex';
  const panel = document.getElementById('panel');
  panel.innerHTML = `
    <h1>MirrorFall</h1>
    <p style="margin:6px 0 0 0">Run ended. Score: <strong>${score}</strong></p>
    <p style="font-size:13px;opacity:0.9;margin-top:8px">The mirror learns each run. Try again — it remembers.</p>
    <div style="margin-top:12px">
      <button id="startBtn2">Try Again</button>
      <button id="shareBtn" style="margin-left:8px;background:#444;padding:8px 12px;border-radius:8px;border:0;color:#fff">Share</button>
    </div>
  `;
  document.getElementById('startBtn2').onclick = ()=>{ panel.innerHTML = ''; panel.appendChild(startBtn); overlay.style.display='none'; startGame(); };
  document.getElementById('shareBtn').onclick = ()=>{ try{ navigator.share ? navigator.share({title:'MirrorFall Score', text:'I scored '+score+' in MirrorFall!'}) : alert('Share this score: '+score); }catch(e){ alert('Share not supported on this device.'); } };
}

/* ---------- Main loop ---------- */
function loop(ts){
  if (!lastTimestamp) lastTimestamp = ts;
  const dt = Math.min(0.033, (ts - lastTimestamp) / 1000); // clamp dt
  lastTimestamp = ts;

  if (running && !paused){
    update(dt);
    drawScene();
    requestAnimationFrame(loop);
  } else {
    // If paused, still draw once
    if (running) drawScene();
  }
}

/* ---------- Initial placement ---------- */
player.x = 180;
player.y = H - 120 - player.h;
player.baseY = player.y;

/* ---------- Simple autoplay demo if user doesn't start (not running) ---------- */
// optional: show ambient animation
(function ambientAnim(){
  let t0 = performance.now();
  function anim(ts){
    const dt = (ts - t0)/1000;
    t0 = ts;
    // slow simple animate mirror left-right if idle
    if (!running){
      // tiny breathing background
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);
      // draw faint title
      ctx.fillStyle = '#fff';
      ctx.font = '48px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('MirrorFall', W/2, H/2 - 60);
    }
    requestAnimationFrame(anim);
  }
  requestAnimationFrame(anim);
})();

/* ---------- Portrait warning helper ---------- */
function checkOrientation(){
  const portraitWarning = document.getElementById('portraitWarning');
  if (window.innerHeight > window.innerWidth) {
    portraitWarning.style.display = 'flex';
  } else portraitWarning.style.display = 'none';
}
window.addEventListener('resize', checkOrientation);
checkOrientation();

/* ---------- Initialize audio placeholders (add your files) ---------- */
/* Example audio usage:
const sJump = new Audio('sfx/jump.wav');
sJump.volume = 0.5;
sJump.play();
*/
// We'll not forceplay audio to avoid autoplay blocking.

/* ---------- End of file ---------- */
</script>

</body>
</html>